
/*  This script generated by Radi - http://radiapp.com

    The Radi JavaScript base library (reproduced within this script) is Copyright 2010-13 Lacquer oy/ltd and released under the so-called MIT license.
    You can freely modify and redistribute this script or portions of it on the following condition:
       The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    This script may also contain portions that were automatically generated by the Radi software from user-provided content
    (such as vector graphics objects and/or custom rendering scripts). That content may be copyrighted by its author(s).
    Lacquer oy/ltd makes no claim of copyright over any content within this script which is not part of the Radi base library.
*/
if (window.requestAnimationFrame === undefined) {
  window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
}
if (window.Radi === undefined) window.Radi = {};
if (Radi.documents === undefined) Radi.documents = {};

Radi.documents['Radi_Preview'] = (function() {
var frameRate = 24;
var durationInFrames = 100;
var currentFrame = 0;
var canPlay = true;
var isPlaying = true;
var animDidStart = false;

var assets = [];

function preloadAssets() {
  for (var i = 0; i < assets.length; i++) {
    var a = assets[i];
    if (a.type === "image" && a.url && !a.img && a.allowPreload) {
      a.img = new Image();
      a.img.src = a.url;
    }
  }
}
function getAssetByName(wanted) {
  for (var i = 0; i < assets.length; i++) {
    if (assets[i].name === wanted) return assets[i];
  }
  return null;
}

var env = { 'durationInFrames': durationInFrames, 'frameRate': frameRate, 'currentFrame': currentFrame };  /* 'env' provides public Radi properties to custom script layers */

function LayerBase(index, lid, element, name, props) {
  this.layerIndex = index;
  this.layerID = lid || ('layer'+index);
  this.name = name || '';
  this.containingElementID = element;
  this.renderProperties = props || {};
  this.variesOverTime = this.renderProperties.variesOverTime || false;
  this.c_opacity = 1;
  this.c_trs = [1, 0, 0, 1, 0, 0];
  this.applyKf = function(frame) {
    this.c_opacity = (this.opValues && (this.opValues.length > frame)) ? this.opValues[frame] : ((this.opValues && this.opValues.length > 0) ? this.opValues[this.opValues.length-1] : 1);
    var trskf = (this.trsValues && (this.trsValues.length > frame)) ? this.trsValues[frame] : null;
    this.c_trs = trskf || (this.prevkf_trs || [1, 0, 0, 1, 0, 0]);
    this.c_invTrs = (this.invTrsValues && (this.invTrsValues.length > frame)) ? this.invTrsValues[frame] : null;
    if (trskf) this.prevkf_trs = trskf;
  }
}

function ShapeLayer(index, lid, elem, name, props) {
  LayerBase.call(this, index, lid, elem, name, props);
}
function ScriptLayer(index, lid, elem, name, props) {
  LayerBase.call(this, index, lid, elem, name, props);
  this.scriptParams = {};
}
function ImageLayer(index, lid, elem, name, props) {
  LayerBase.call(this, index, lid, elem, name, props);
}
function TextLayer(index, lid, elem, name, props) {
  LayerBase.call(this, index, lid, elem, name, props);
}

var layers = [
];

var elements = [
  { "htmlID": "Radi_Preview_z1_video_preview3ad60b2c", "name": "Video element (1)", "layerIndexes": [], "describeAtFrame": function(frame) { var infr = -7; var dur = -1; var isVisible = (frame >= infr && (dur < 0 || frame < infr+dur)); return { 'isVisible': isVisible, 'needsRender': false, 'needsLoad': true, 'needsPlay': (frame>=infr) } }, "eventHandlers": { }, "setup": function() { var baseEl = document.getElementById(this.htmlID);
 var filterEl = document.createElement('canvas');
 filterEl.id = this.htmlID+'_webGLFilterCanvas';
 filterEl.width = baseEl.width;
 filterEl.height = baseEl.height;
 var style = baseEl.style;
 for (var i = 0; i < style.length; i++) {
  filterEl.style.setProperty(style[i], style.getPropertyValue(style[i]), '');
 }
 var parent = baseEl.parentNode;
 parent.appendChild(filterEl);
 var filter = glFilter_281889;
 if ( !filter.init(filterEl.id)) {
  parent.removeChild(filterEl);
  canPlay = false;
  return false;
 } else {
  this.glFilter = filter;
  this.glFilterCanvas = filterEl;
  var idx = this.htmlID.indexOf('_z');
  var baseZ = (idx > -1) ? parseInt(this.htmlID.substr(idx + 2)) : 100;
  filterEl.style.zIndex = baseZ + 1;
  baseEl.style.position = 'absolute';
  filterEl.style.position = 'absolute';
  filterEl.style.visibility = 'visible';
  filterEl.style.opacity = 1;
  baseEl.style.opacity = 0.01;
  if ($) {
    baseEl = $(baseEl);
    filterEl = $(filterEl);
    filterEl.bind({'click': function(event){baseEl.click();},
                   'mousedown': function(event){baseEl.mousedown();},
                   'mousemove': function(event){baseEl.mousemove();},
                   'mouseup': function(event){baseEl.mouseup();}
            });
  }
  return true;
 }
} }];

var glFilter_281889 = (function() {
/* Radi WebGL filter module */
var gl;
var canvasId;

function initGL(a_canvasId) {
  canvasId = a_canvasId;
  canvas = document.getElementById(canvasId);
  try {
    gl = canvas.getContext("experimental-webgl");
    gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;
  } catch(e) { }
  if ( !gl) {
    var err = "WebGL is not available in your browser.\n\n"+
          "This page uses WebGL to render visual effects.\nWebGL is a 3D graphics standard that is available in many new browsers "+
        "including Chrome, Firefox and Safari.";
  if (ua.indexOf('safari') != -1) {
      err += "\n\n---\nYou're using Safari, but WebGL is not currently enabled. To enable it, do the following:\n\n"+
           "• From the Safari menu, choose Preferences -> Advanced -> toggle 'Show Develop menu'\n\n"+
           "• In the Develop menu, toggle 'Enable WebGL'\n\n";
    }
    alert(err);
    return false;
  }
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  return true;
}

var shaderProgram;

function loadShaderUsingGenFunc(genFunc, arg) {
  shaderProgram = genFunc(gl, arg);
  if ( !shaderProgram) return false;
  
  gl.useProgram(shaderProgram);

  shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "a_vertexPosition");
  gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

  shaderProgram.texcoordAttribute = gl.getAttribLocation(shaderProgram, "a_texcoord");
  gl.enableVertexAttribArray(shaderProgram.texcoordAttribute);
  
  shaderProgram.projMatrixUniform = gl.getUniformLocation(shaderProgram, "projMatrix");
  shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "mvMatrix");
  shaderProgram.imageSizeUniform = gl.getUniformLocation(shaderProgram, "imageSize");
  shaderProgram.sampler0Uniform = gl.getUniformLocation(shaderProgram, "sampler0");
  
  var fpls = [];
  for (var i = 0; i < 8; i++) {
    fpls.push(gl.getUniformLocation(shaderProgram, "programLocal"+i));
  }
  shaderProgram.fsProgramLocalUniforms = fpls;
  
  return true;
}

var defaultShaderGenFunc = function(gl, resInfo) {
if ( !resInfo) resInfo = {'name':'-'};
fs = gl.createShader(gl.FRAGMENT_SHADER);
/* This shader program was compiled in Radi from a visual Conduit effect. 
   If you reuse this shader, please be kind and retain the comment in the code.
*/
gl.shaderSource(fs, "/* Shader generated using Radi - http://radiapp.com */precision mediump float;\nvarying vec2 texcoord0;\nvarying vec2 texcoordPx;\nuniform sampler2D sampler0;\nuniform vec4 programLocal0;\nuniform vec4 programLocal1;\nuniform vec4 programLocal2;\nvoid main(void) {\nvec4 imageInfo = programLocal0;\nvec4 var1; \nvec4 temp1; vec4 temp2; \nvec4 image1; \nimage1 = texture2D(sampler0, vec2(texcoord0.s, texcoord0.t));\nvar1.r = dot(vec3(image1), vec3(vec4(1.000000, 0.080000, 0.168000, 0.0)));\nvar1.g = dot(vec3(image1), vec3(vec4(0.260000, 0.676000, 0.066000, 0.0)));\nvar1.b = dot(vec3(image1), vec3(vec4(0.152000, 0.066000, 0.458000, 0.0)));\nvar1.a = image1.a;\ntemp1 = var1;\nvar1.r = dot(vec3(temp1), vec3(vec4(1.021400, -0.019438, -0.001962, 0.0)));\nvar1.g = dot(vec3(temp1), vec3(vec4(-0.005778, 1.007740, -0.001962, 0.0)));\nvar1.b = dot(vec3(temp1), vec3(vec4(-0.005778, -0.019438, 1.025216, 0.0)));\ntemp1 = vec4(0.325000 * var1 + -0.240000);\ntemp1 = temp1 * var1 + 0.915000;\ntemp1 = temp1 * var1 + 0.0;\ntemp2 = vec4(0.975000 * var1 + -0.480000);\ntemp2 = temp2 * var1 + 0.915000;\ntemp2.r = 1.0 / temp2.r;\ntemp2.g = 1.0 / temp2.g;\ntemp2.b = 1.0 / temp2.b;\ntemp2.a = 1.0 / temp2.a;\ntemp1 = temp1 - var1;\ntemp1 = temp1 * temp2;\ntemp1 = var1 - temp1;\ntemp2 = vec4(-0.867500 * temp1 + 1.357500);\ntemp2 = temp2 * temp1 + 0.510000;\nvar1 = temp2 * temp1 + 0.0;\nvar1.a = clamp(var1.a, 0.0, 1.0);\nvar1.rgb = var1.rgb * var1.a;\ngl_FragColor = var1;}");
gl.compileShader(fs);
if ( !gl.getShaderParameter(fs, gl.COMPILE_STATUS)) { alert("Oh no, something has gone wrong!\n\nThe WebGL effect created by Radi seems to contain an error. This is probably due to a bug in Radi.\n\nIf you're the author of this web page, could you let the Radi developer know about this issue? His email address is:\n  pauli@lacquer.fi\n\nPlease include the following error info:\n\nWebGL fragment shader compile error ('"+resInfo.name+"'): "+gl.getShaderInfoLog(fs)); return null; }

vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, "attribute vec3 a_vertexPosition;attribute vec2 a_texcoord;uniform mat4 projMatrix;uniform mat4 mvMatrix;uniform vec2 imageSize;varying vec2 texcoord0;varying vec2 texcoordPx;void main(void) {  gl_Position = projMatrix * mvMatrix * vec4(a_vertexPosition, 1.0);  texcoord0 = a_texcoord;  texcoordPx = vec2(a_texcoord.x * imageSize.x, a_texcoord.y * imageSize.y);}");
gl.compileShader(vs);
if ( !gl.getShaderParameter(vs, gl.COMPILE_STATUS)) { alert("WebGL vertex shader compile error ('"+resInfo.name+"'): "+gl.getShaderInfoLog(vs)); return null; }
var sp = gl.createProgram();
gl.attachShader(sp, vs);
g…